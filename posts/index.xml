<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on hieudoan7</title>
    <link>https://1612198.github.io/posts/</link>
    <description>Recent content in Posts on hieudoan7</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 10 Jul 2019 22:42:22 +0700</lastBuildDate>
    
	<atom:link href="https://1612198.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>KMP Algorithm</title>
      <link>https://1612198.github.io/posts/kmp-algorithm/</link>
      <pubDate>Wed, 10 Jul 2019 22:42:22 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/kmp-algorithm/</guid>
      <description>Knuth-Morris-Pratt algorithm 10/07/2019
I. Bài toán: Cho chuỗi Text $T$ (length = $n$) và Pattern $P$ (length = $m$). Tìm số lần xuất hiện của $P$ trong $T$.
$\Rightarrow$ Naive Solution:
Tại mỗi vị trí $i$ trong $T$, ta so sánh nó với $P$.
&amp;gt; code chơi thôi:
int cnt = 0; for (int i = 0; i &amp;lt;= n-m; i++){ bool flag = false; for (int j = 0; j &amp;lt; m; j++){ if (P[j] == T[i+j]) continue; flag = true; break; } if (flag) cnt++; }  $$\Rightarrow O(n*m) $$</description>
    </item>
    
    <item>
      <title>Floyd-Warshall Algorithm</title>
      <link>https://1612198.github.io/posts/floyd-warshall_algorithm/</link>
      <pubDate>Tue, 09 Jul 2019 21:06:45 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/floyd-warshall_algorithm/</guid>
      <description>Floyd-Warshall algorithm 09/07/2019
I. Mục đích All pair shortest path
Tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh.
II. Ý tưởng: Quy hoạch động dựa vào đỉnh trung gian.
Với đỉnh trung gian đang xét là $k$, thì những $shortest\_path$ mà có các đỉnh trung gian thuộc $[1..k]$ sẽ được tìm thấy (kết quả cuối cùng luôn), còn những cái path kia thì có ngắn hơn nhưng chưa phải ngắn nhất vì nó còn đường ngắn hơn là đi qua đỉnh trung gian mà ta chưa cover tới.</description>
    </item>
    
    <item>
      <title>Dijikstra Algorithm</title>
      <link>https://1612198.github.io/posts/dijistra_algorithm/</link>
      <pubDate>Tue, 09 Jul 2019 00:06:06 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/dijistra_algorithm/</guid>
      <description>Dijikstra Algorithm 08/07/2019
I. Mục đích: Tìm đường đi ngắn nhất từ 1 node (starting node) đến tất cả các nodes còn lại.
Nhược điểm: Kết quả SAI khi đồ thị cạnh âm chứ chưa cần có mạch âm.
Ưu điểm: So với Bellman-ford, Dijistra hiệu quả hơn vì chỉ duyệt qua các cạnh đúng 1 lần.
II. Ý tưởng: Luôn lan truyền đến node gần nhất với starting node x.</description>
    </item>
    
    <item>
      <title>Bellman-Ford Algorithm</title>
      <link>https://1612198.github.io/posts/bellman-ford_algorithm/</link>
      <pubDate>Mon, 08 Jul 2019 21:43:13 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/bellman-ford_algorithm/</guid>
      <description>Bellman-Ford Algorithm 08/07/2019
I. Mục đích Tìm đường đi ngắn nhất từ 1 node (starting node) đến tất cả các nodes còn lại.
Ưu điểm: Có thể phát hiện mạch âm
II. Ý tưởng: Gọi $distance[i]$ là đường đi ngắn nhất từ đỉnh $x$ (starting node) đến đỉnh i ($distance[x] = 0$)
 Sau lần round 1: những đỉnh $i$ kề $x$ sẽ xác định được $distance[i]$ (final value luôn đó)</description>
    </item>
    
    <item>
      <title>Z-function</title>
      <link>https://1612198.github.io/posts/z-function/</link>
      <pubDate>Sun, 07 Jul 2019 14:27:00 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/z-function/</guid>
      <description>th, td { padding: 1.0rem; } table, th, td { border: 2px solid black; } 
String Processing 18/04/2019
Cho 2 xâu P (pattern) và S (string). Mộ số bài toán
 Tìm vị trí xuất hiện đầu tiên của P trong S Đếm số lần xuất hiện P trong S Cho S, tìm P ngắn nhất để repeat P nhiều lần ta được S &amp;hellip;  I. Z-function 1.</description>
    </item>
    
    <item>
      <title>Polish Notation</title>
      <link>https://1612198.github.io/posts/polishnotation/</link>
      <pubDate>Sat, 29 Jun 2019 11:20:28 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/polishnotation/</guid>
      <description>Polist Notation 29/06/2019
I. Kí pháp Balan là gì? (What is Polish Notation) Kí pháp Balan là một dạng viết khác của biểu thức toán học.
 Balan tiền tố (prefix): Đưa các toán tử lên đầu
 Balan ngược: Đưa các toán tử ra sau cùng
  Trong kí pháp Balan, các dấu ngoặc bị lược bỏ
Ví dụ: Xét biểu thức: $3 + 5*(6-3) + 1$</description>
    </item>
    
    <item>
      <title>Fenwick Tree - Binary Indexed Tree</title>
      <link>https://1612198.github.io/posts/fenwicktree/</link>
      <pubDate>Tue, 25 Jun 2019 13:25:20 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/fenwicktree/</guid>
      <description>Binary Indexed Tree (Fenwick Tree) 24/06/2019
Định nghĩa: Fenwick Tree (Binary Indexed Tree) là một CTDL với n node (n+1 nodes với node gốc bù nhìn) chứa thông tin (thường là tổng cộng dồn) về các phần tử trong đoạn (i-(i&amp;amp;-i), i] (mảng tính từ 1)
* Nhận xét: Cây getSum vs cây Update khác nhau:
- in GetSum: parent(i) = i-(i&amp;amp;-i)
- in Update: parent(i) = i+(i&amp;amp;-i)
Mục đích: Mục đích cây này là để tính range sum và khi update 1 phần tử trong mảng a thì các range sum involved cũng được update với chi phí thấp.</description>
    </item>
    
    <item>
      <title>Kosaraju&#39;s Algorithm Intuition</title>
      <link>https://1612198.github.io/posts/kosaraju/</link>
      <pubDate>Tue, 18 Jun 2019 15:01:41 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/kosaraju/</guid>
      <description>Kosaraju &amp;rsquo;s Algorithms 17/06/2019
I. DFS Tree Output của thuật toán DFS là 1 cây khung (spanning tree) Tất cả các cạnh của đồ thị gốc sẽ được chia làm 4 loại trong DFS spanning Tree:
 Tree Edge (sometimes Tree Edge được xếp vào Forward Edge) Forward Edge Back Edge Cross Edge  Example If the original graph is undirected then all of its edges are tree edge or black edge</description>
    </item>
    
    <item>
      <title>Hugo Tutorial</title>
      <link>https://1612198.github.io/posts/hugo-tutorial/</link>
      <pubDate>Fri, 19 Apr 2019 15:01:41 +0700</pubDate>
      
      <guid>https://1612198.github.io/posts/hugo-tutorial/</guid>
      <description>Hugo Tutorial 18.06.2019
I. Install Hugo &amp;amp; Setup Theme 2 best tutorial about hugo
part 1 part 2
Về cơ bản, chúng ta host blog lên github sẽ tạo 2 repository
 Repo 1: hieudoan7: chứa các file config của hugo, content, nói chung tất tần tật. Repo 2: 1612198.github.io: repo này chứa file html để render lên web  Chú ý: dateformat trong file config.toml (ở thư mục gốc, thư mục mà ta có thể sử dụng hugo command) phải để ở ngày 2.</description>
    </item>
    
    <item>
      <title>The Fine Art of Small Talk</title>
      <link>https://1612198.github.io/posts/the-fine-art-of-small-talk/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1612198.github.io/posts/the-fine-art-of-small-talk/</guid>
      <description>Small Talk Note 05/04/2019
Em học được gì qua nội dung quyển sách? Contents  Chapter 1: What&amp;rsquo;s Big Deal About Small Talk? Chapter 2: Get Over Your Mom &amp;rsquo;s Intentions Chapter 3: Take the Plunge: Start a Conversation! Chapter 4: Keep the Conservation Going! Chapter 5: Let&amp;rsquo;s Give &amp;lsquo;Em Something to Talk About Chapter 6: Hearing Aids and Listening Devices Chapter 7: Prevent Pregmant Pauses with Preparationg Chapter 8: Conservation Clout Chapter 9: Crimes and Misdemeanors Chapter 10: The Graceful Exit Chapter 11: The Conservation Ball Is in Your Court!</description>
    </item>
    
  </channel>
</rss>